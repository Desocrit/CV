---
import ActionButton from './ActionButton.astro';

interface Props {
  title: string;
  id?: string;
  class?: string;
  titleClass?: string;
  contentClass?: string;
  printHide?: boolean;
}

const { title, id, class: className = '', titleClass = '', contentClass = '', printHide = false } = Astro.props;
const headingId = id ? `${id}-heading` : undefined;
const contentId = id ?? `section-${Math.random().toString(36).slice(2, 9)}`;
const formatTitle = (s: string) => s.toUpperCase().replace(/\s+/g, '_');
---

<section
  class:list={[
    'group my-[var(--spacing-fluid-md)] lg:my-[var(--spacing-fluid-sm)] lg:first:mt-0 [--section-label-width:140px]',
    'lg:[&:first-child_.section-header]:pt-0 lg:[&:first-child_.section-header]:border-t-0',
    'lg:[&:first-child_[data-content]]:pt-0',
    '[&.is-collapsed_[data-content]]:hidden',
    'print:my-0',
    printHide && 'print:hidden',
    className,
  ]}
  data-section
  id={id}
  aria-labelledby={headingId}
  data-section-id={id}
  style="--section-accent: var(--color-accent-green);"
>
  <div class="flex flex-col lg:gap-[var(--spacing-fluid-xs)] xl:grid xl:grid-cols-[var(--section-label-width)_1fr] xl:gap-[var(--spacing-fluid-sm)] print:block">
    <div
      class:list={[
        'section-header',
        'sticky top-[-1px] z-20 flex items-center justify-between',
        'w-screen ml-[calc(-1*var(--spacing-fluid-md))] px-[var(--spacing-fluid-md)] py-2.5',
        'bg-background border-y border-[var(--section-accent)]',
        'light:border-border light:pl-0 light:pr-[var(--spacing-fluid-xs)] light:w-auto light:ml-0',
        'lg:relative lg:top-auto lg:z-10 lg:w-auto lg:ml-0 lg:p-0 lg:bg-transparent lg:border-none lg:justify-start',
        'xl:sticky xl:top-[var(--spacing-fluid-sm)] xl:self-start xl:bg-background xl:pt-[var(--spacing-fluid-sm)]',
        'print:static print:w-auto print:m-0 print:mb-2 print:!p-0 print:bg-transparent print:border-none',
        '[[data-theme=light]_&.is-active]:border-[var(--section-accent)]',
      ]}
    >
      <button
        type="button"
        class="section-toggle inline-flex items-center border-none p-0 m-0 bg-transparent cursor-pointer relative focus-visible:outline-2 focus-visible:outline-[var(--section-accent)] focus-visible:outline-offset-2 lg:contents print:contents before:content-[''] before:absolute before:inset-[-0.75rem] before:min-w-[44px] before:min-h-[44px] before:print:hidden"
        aria-expanded="true"
        aria-controls={contentId}
        aria-label={`Toggle ${title} section`}
      >
        <span class:list={['section-title block font-mono text-fluid-2xs uppercase tracking-[0.1em] leading-[1.6] whitespace-nowrap text-[var(--section-accent)] lg:text-accent-green lg:mb-[var(--spacing-fluid-2xs)] light:hidden print:!hidden', titleClass]} aria-hidden="true">
          <span class="section-prefix">// </span>
          <span class="section-title-text">{formatTitle(title)}</span>
          <span class="section-context opacity-0 [&:not(:empty)]:opacity-100 transition-opacity duration-200 lg:hidden [&:not(:empty)]:before:content-['/_']"></span>
        </span>
        <span class="section-title-clean hidden font-['IBM_Plex_Sans',system-ui,sans-serif] text-fluid-sm font-semibold uppercase tracking-[0.1em] text-foreground light:block lg:light:pb-[var(--spacing-fluid-sm)] lg:light:border-b lg:light:border-b-border xl:light:inline-block xl:light:border-none print:!block print:text-left print:uppercase print:font-mono print:font-medium print:text-[10px] print:tracking-widest print:text-[var(--color-print-muted)] print:border-solid print:border-t-[0.5px] print:border-[var(--color-print-body)] print:w-full print:pt-1.5 print:pb-0 print:mb-2" aria-hidden="true">{title}</span>
      </button>

      <ActionButton
        label="^"
        class="scroll-top-btn shrink-0 relative z-2 lg:hidden print:!hidden before:content-[''] before:absolute before:inset-[-0.5rem] before:z-[1] before:print:hidden [&_.bracket]:text-[var(--section-accent)] [&_.label]:text-[var(--section-accent)]"
        screenReaderLabel="Scroll to top"
      />
    </div>

    <div
      class:list={['section-content w-full min-w-0 pt-[var(--spacing-fluid-sm)] lg:pt-0 xl:pt-[var(--spacing-fluid-sm)] print:pt-0', contentClass]}
      data-content
      id={contentId}
    >
      <h2 id={headingId} class="sr-only">{title}</h2>
      <slot />
    </div>
  </div>
</section>

<script>
  const initSection = () => {
    document.querySelectorAll('.scroll-top-btn').forEach(btn =>
      btn.addEventListener('click', e => { e.preventDefault(); e.stopPropagation(); window.scrollTo({ top: 0, behavior: 'smooth' }); })
    );

    // Only apply scroll-based active states on xs/sm screens (below md breakpoint)
    if (!matchMedia('(max-width: 729px)').matches) return;

    document.querySelectorAll('.section-toggle').forEach(toggle =>
      toggle.addEventListener('click', () => {
        const section = toggle.closest('[data-section]');
        if (section) toggle.setAttribute('aria-expanded', String(!section.classList.toggle('is-collapsed')));
      })
    );

    const sections = document.querySelectorAll('[data-section]');
    if (!sections.length) return;

    const toScreamingCase = (s: string) => s.toUpperCase().replace(/\s+/g, '_').replace(/'/g, '');
    const getContextText = (card: Element) =>
      toScreamingCase(
        card.querySelector('.card-header')?.textContent?.trim().replace(/^\[\s*|\s*\]$/g, '') ||
        card.querySelector('.label-text .screen-only')?.textContent?.trim() ||
        card.querySelector('.card-title')?.textContent?.trim() || ''
      );

    const updateSections = () => sections.forEach(section => {
      const rect = section.getBoundingClientRect();
      const header = section.querySelector('.section-header');
      const context = section.querySelector('.section-context') as HTMLElement | null;
      const cards = section.querySelectorAll('.content-card, .impact-card-wrapper');
      const el = section as HTMLElement;

      if (rect.top <= 10 && rect.bottom > 50) {
        header?.classList.add('is-active');
        let active: Element | null = null, highest = -Infinity;
        cards.forEach(c => { const r = c.getBoundingClientRect(); if (r.top <= 80 && r.bottom > 0 && r.top > highest) { highest = r.top; active = c; } });
        cards.forEach(c => c.classList.remove('is-active-card'));
        if (active) {
          (active as Element).classList.add('is-active-card');
          // For impact cards in 2-column layout, also activate sibling cards with same header
          const activeHeader = (active as HTMLElement).dataset['header'];
          if (activeHeader && (active as Element).classList.contains('impact-card-wrapper')) {
            cards.forEach(c => {
              if (c !== active && (c as HTMLElement).dataset['header'] === activeHeader) {
                c.classList.add('is-active-card');
              }
            });
          }
          const accent = getComputedStyle(active).getPropertyValue('--card-accent').trim();
          if (accent) el.style.setProperty('--section-accent', accent);
          if (context) context.textContent = getContextText(active);
        }
      } else {
        header?.classList.remove('is-active');
        el.style.setProperty('--section-accent', 'var(--color-accent-green)');
        if (context) context.textContent = '';
        cards.forEach(c => c.classList.remove('is-active-card'));
      }
    });

    let ticking = false;
    addEventListener('scroll', () => { if (!ticking) { ticking = true; requestAnimationFrame(() => { updateSections(); ticking = false; }); } }, { passive: true });
    updateSections();
  };

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initSection);
  else initSection();
  document.addEventListener('astro:page-load', initSection);
</script>
