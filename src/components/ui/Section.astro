---
import ActionButton from './ActionButton.astro';
import SectionHeader from './SectionHeader.astro';
import SectionTitle from './SectionTitle.astro';

/**
 * Section - Collapsible content section with responsive header
 *
 * Features:
 * - Mobile: Sticky header with scroll-to-top
 * - Desktop: Side column layout at xl
 * - Accordion toggle on all screen sizes
 * - Dynamic accent color from active cards (mobile)
 */

export type AccentColor = 'green' | 'orange' | 'blue' | 'purple' | 'red' | 'cyan';

interface Props {
  title: string;
  id?: string;
  class?: string;
  contentClass?: string;
  /** Colors for content list hover effects (nth-child based) */
  hoverColors?: AccentColor[];
  /** Enable impact card hover effects (color-class based) */
  hoverImpact?: boolean;
  printHide?: boolean;
  printHideTitle?: boolean;
  printBorderBottom?: boolean;
}

const {
  title,
  id,
  class: className = '',
  contentClass = '',
  hoverColors,
  hoverImpact = false,
  printHide = false,
  printHideTitle = false,
  printBorderBottom = false,
} = Astro.props;

const headingId = id ? `${id}-heading` : undefined;
const contentId = id ?? `section-${Math.random().toString(36).slice(2, 9)}`;

// Generate hover color classes for content lists (nth-child based)
const contentHoverClasses = hoverColors?.length
  ? [
      'transition-colors duration-150 ease-out',
      ...hoverColors.map((color, i) =>
        `min-[1200px]:group-has-[.content-list-item:nth-child(${i + 1}):hover]:[color:var(--color-accent-${color})]`
      ),
    ].join(' ')
  : '';

// Impact hover classes (fixed set of 6 colors, color-class based)
const impactHoverClasses = hoverImpact
  ? [
      'transition-colors duration-150 ease-out',
      'min-[1300px]:group-has-[.impact-card-wrapper--green:hover]:[color:var(--color-accent-green)]',
      'min-[1300px]:group-has-[.impact-card-wrapper--blue:hover]:[color:var(--color-accent-blue)]',
      'min-[1300px]:group-has-[.impact-card-wrapper--purple:hover]:[color:var(--color-accent-purple)]',
      'min-[1300px]:group-has-[.impact-card-wrapper--orange:hover]:[color:var(--color-accent-orange)]',
      'min-[1300px]:group-has-[.impact-card-wrapper--red:hover]:[color:var(--color-accent-red)]',
      'min-[1300px]:group-has-[.impact-card-wrapper--cyan:hover]:[color:var(--color-accent-cyan)]',
    ].join(' ')
  : '';

const titleHoverClasses = contentHoverClasses || impactHoverClasses;
---

<section
  class:list={[
    'group',
    'my-[var(--spacing-fluid-md)] lg:my-[var(--spacing-fluid-sm)] lg:first:mt-0',
    '[--section-label-width:140px]',
    // First-child rules
    'lg:[&:first-child_.section-header]:pt-0 lg:[&:first-child_.section-header]:border-t-0',
    'lg:[&:first-child_[data-content]]:pt-0',
    // Collapse state
    '[&.is-collapsed_[data-content]]:hidden',
    // Print
    'print:my-0',
    printHide && 'print:hidden',
    printBorderBottom && 'print:mb-4',
    className,
  ]}
  data-section
  id={id}
  aria-labelledby={headingId}
  data-section-id={id}
  style="--section-accent: var(--color-accent-green);"
>
  <div class="flex flex-col lg:gap-[var(--spacing-fluid-xs)] xl:grid xl:grid-cols-[var(--section-label-width)_1fr] xl:gap-[var(--spacing-fluid-sm)] print:block">
    <SectionHeader printHide={printHideTitle}>
      <button
        type="button"
        class="section-toggle inline-flex items-center border-none p-0 m-0 bg-transparent cursor-pointer relative focus-visible:outline-2 focus-visible:outline-[var(--section-accent)] focus-visible:outline-offset-2 lg:contents print:contents before:content-[''] before:absolute before:inset-[-0.75rem] before:min-w-[44px] before:min-h-[44px] before:print:hidden"
        aria-expanded="true"
        aria-controls={contentId}
        aria-label={`Toggle ${title} section`}
      >
        <SectionTitle title={title} class={titleHoverClasses} showContext />
      </button>

      <ActionButton
        label="^"
        class="scroll-top-btn shrink-0 relative z-2 lg:hidden print:!hidden before:content-[''] before:absolute before:inset-[-0.5rem] before:z-[1] before:print:hidden [&_.bracket]:text-[var(--section-accent)] [&_.label]:text-[var(--section-accent)] [&_.label]:light:text-muted-foreground"
        screenReaderLabel="Scroll to top"
      />
    </SectionHeader>

    <div
      class:list={[
        'section-content w-full min-w-0',
        'pt-[var(--spacing-fluid-sm)] lg:pt-0 xl:pt-[var(--spacing-fluid-sm)] print:pt-0',
        contentClass,
      ]}
      data-content
      id={contentId}
    >
      <h2 id={headingId} class="sr-only">{title}</h2>
      <slot />
    </div>
  </div>
</section>

<script>
  const initSection = () => {
    // Scroll-to-top
    document.querySelectorAll('.scroll-top-btn').forEach(btn =>
      btn.addEventListener('click', e => {
        e.preventDefault();
        e.stopPropagation();
        window.scrollTo({ top: 0, behavior: 'smooth' });
      })
    );

    // Accordion toggle
    document.querySelectorAll('.section-toggle').forEach(toggle =>
      toggle.addEventListener('click', () => {
        const section = toggle.closest('[data-section]');
        if (section) {
          toggle.setAttribute('aria-expanded', String(!section.classList.toggle('is-collapsed')));
        }
      })
    );

    // Mobile scroll-based active states (below md breakpoint only)
    if (!matchMedia('(max-width: 729px)').matches) return;

    const sections = document.querySelectorAll('[data-section]');
    if (!sections.length) return;

    const toScreamingCase = (s: string) =>
      s.toUpperCase().replace(/\s+/g, '_').replace(/'/g, '');

    const getContextText = (card: Element) =>
      toScreamingCase(
        card.querySelector('.card-header')?.textContent?.trim().replace(/^\[\s*|\s*\]$/g, '') ||
        card.querySelector('.label-text .screen-only')?.textContent?.trim() ||
        card.querySelector('.card-title')?.textContent?.trim() || ''
      );

    const updateSections = () => {
      sections.forEach(section => {
        const rect = section.getBoundingClientRect();
        const header = section.querySelector('.section-header');
        const context = section.querySelector('.section-context') as HTMLElement | null;
        const cards = section.querySelectorAll('.content-card, .impact-card-wrapper');
        const el = section as HTMLElement;

        if (rect.top <= 10 && rect.bottom > 50) {
          header?.classList.add('is-active');

          // Find active card (highest one in viewport)
          let active: Element | null = null;
          let highest = -Infinity;
          cards.forEach(c => {
            const r = c.getBoundingClientRect();
            if (r.top <= 80 && r.bottom > 0 && r.top > highest) {
              highest = r.top;
              active = c;
            }
          });

          cards.forEach(c => c.classList.remove('is-active-card'));

          if (active) {
            (active as Element).classList.add('is-active-card');

            // Impact cards: also activate siblings with same header in 2-column layout
            const activeHeader = (active as HTMLElement).dataset['header'];
            const isSmBreakpoint = matchMedia('(min-width: 560px)').matches;
            if (activeHeader && isSmBreakpoint && (active as Element).classList.contains('impact-card-wrapper')) {
              cards.forEach(c => {
                if (c !== active && (c as HTMLElement).dataset['header'] === activeHeader) {
                  c.classList.add('is-active-card');
                }
              });
            }

            // Update section accent color from card
            const accent = getComputedStyle(active).getPropertyValue('--card-accent').trim();
            if (accent) el.style.setProperty('--section-accent', accent);
            if (context) context.textContent = '/' + getContextText(active);
          }
        } else {
          header?.classList.remove('is-active');
          el.style.setProperty('--section-accent', 'var(--color-accent-green)');
          if (context) context.textContent = '';
          cards.forEach(c => c.classList.remove('is-active-card'));
        }
      });
    };

    let ticking = false;
    addEventListener('scroll', () => {
      if (!ticking) {
        ticking = true;
        requestAnimationFrame(() => {
          updateSections();
          ticking = false;
        });
      }
    }, { passive: true });
    updateSections();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSection);
  } else {
    initSection();
  }
  document.addEventListener('astro:page-load', initSection);
</script>
