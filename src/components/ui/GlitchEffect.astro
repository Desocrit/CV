---
// Subtle "glitch in the matrix" effect for section titles
// Occasionally flickers a few letters to random characters
---

<script>
  const GLITCH_CHARS = '!@#$%^&*()_+-=[]{}|;:,.<>?0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const INITIAL_DELAY = 7500; // 7.5 seconds before first glitch
  const MIN_INTERVAL = 1500; // 1.5 seconds minimum between glitches
  const MAX_INTERVAL = 3500; // 3.5 seconds maximum between glitches
  const GLITCH_DURATION = 300; // How long the glitch lasts
  const GLITCH_FRAMES = 5; // Number of glitch frames

  // Track elements currently being animated to prevent race conditions
  const animatingElements = new WeakSet<HTMLElement>();

  function getRandomChar(): string {
    return GLITCH_CHARS[Math.floor(Math.random() * GLITCH_CHARS.length)] ?? '?';
  }

  function glitchText(element: HTMLElement): void {
    // Prevent overlapping animations on the same element
    if (animatingElements.has(element)) return;

    // Get the stored original text (set at initialization)
    const original = element.dataset['originalText'];
    if (!original) return;

    animatingElements.add(element);

    // Pick 2-4 random positions to glitch
    const numGlitches = 2 + Math.floor(Math.random() * 3);
    const positions = new Set<number>();
    while (positions.size < numGlitches && positions.size < original.length) {
      const pos = Math.floor(Math.random() * original.length);
      // Skip underscores and spaces
      if (original[pos] !== '_' && original[pos] !== ' ') {
        positions.add(pos);
      }
    }

    const posArray = Array.from(positions);
    let frame = 0;

    const animate = () => {
      if (frame >= GLITCH_FRAMES) {
        // Restore from the stored original (guaranteed correct)
        element.textContent = original;
        animatingElements.delete(element);
        return;
      }

      // Create glitched version
      const chars = original.split('');
      posArray.forEach(pos => {
        chars[pos] = getRandomChar();
      });
      element.textContent = chars.join('');
      frame++;

      setTimeout(animate, GLITCH_DURATION / GLITCH_FRAMES);
    };

    animate();
  }

  function scheduleNextGlitch(titles: HTMLElement[]): void {
    const delay = MIN_INTERVAL + Math.random() * (MAX_INTERVAL - MIN_INTERVAL);

    setTimeout(() => {
      // Pick a random title to glitch
      const target = titles[Math.floor(Math.random() * titles.length)];
      if (target) {
        glitchText(target);
      }
      scheduleNextGlitch(titles);
    }, delay);
  }

  // Section titles that should glitch (Nova-related and Emerging Frontier content)
  // History and Education sections remain stable
  const GLITCH_SECTIONS = ['PROJECTS', 'IMPACT'];

  // Track if glitch effect is currently active
  let glitchTimeoutId: number | null = null;
  let isGlitchActive = false;

  function isDarkMode(): boolean {
    return document.documentElement.getAttribute('data-theme') !== 'light';
  }

  function startGlitchEffect(titles: HTMLElement[]): void {
    if (isGlitchActive || titles.length === 0) return;
    isGlitchActive = true;

    // Store original text on each element ONCE at initialization
    // This ensures we always have the true original, even during race conditions
    titles.forEach(el => {
      if (!el.dataset['originalText']) {
        el.dataset['originalText'] = el.textContent || '';
      }
    });

    // Wait before starting glitch effects
    glitchTimeoutId = window.setTimeout(() => {
      scheduleNextGlitch(titles);
    }, INITIAL_DELAY);
  }

  function stopGlitchEffect(titles: HTMLElement[]): void {
    isGlitchActive = false;

    // Clear any pending timeout
    if (glitchTimeoutId !== null) {
      clearTimeout(glitchTimeoutId);
      glitchTimeoutId = null;
    }

    // Restore original text on all elements
    titles.forEach(el => {
      const original = el.dataset['originalText'];
      if (original) {
        el.textContent = original;
      }
      animatingElements.delete(el);
    });
  }

  function init(): void {
    const allTitles = Array.from(
      document.querySelectorAll('.section-title-text')
    ) as HTMLElement[];

    // Filter to only titles in allowed sections
    const titles = allTitles.filter(el => {
      const text = el.textContent?.trim() || '';
      return GLITCH_SECTIONS.includes(text);
    });

    if (titles.length === 0) return;

    // Only start if in dark mode
    if (isDarkMode()) {
      startGlitchEffect(titles);
    }

    // Watch for theme changes
    const observer = new MutationObserver(() => {
      if (isDarkMode()) {
        startGlitchEffect(titles);
      } else {
        stopGlitchEffect(titles);
      }
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-theme']
    });
  }

  // Defer initialization to avoid impacting Lighthouse scores
  function deferInit(): void {
    // Respect reduced motion preferences
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      return;
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  }

  // Use requestIdleCallback to defer non-critical visual effects
  if ('requestIdleCallback' in window) {
    requestIdleCallback(deferInit, { timeout: 3000 });
  } else {
    // Fallback for Safari and older browsers
    setTimeout(deferInit, 1000);
  }
</script>
