---
/**
 * Odometer Component
 * Displays a number with a forensic "diagnostic scan" animation.
 * Features a scramble phase followed by count-up, triggered on viewport entry.
 * Animation is disabled for print media and reduced motion preferences.
 */

interface Props {
  value: string;
  class?: string;
}

const { value, class: className = '' } = Astro.props;

// Parse the value to extract numeric parts and prefixes/suffixes
// Examples: "1000x" -> { prefix: "", number: 1000, suffix: "x" }
//           "$500k" -> { prefix: "$", number: 500, suffix: "k" }
//           "2800"  -> { prefix: "", number: 2800, suffix: "" }
const parseValue = (val: string) => {
  const match = val.match(/^([^\d]*)(\d+)([^\d]*)$/);
  if (!match) return { prefix: '', number: 0, suffix: '', raw: val };
  return {
    prefix: match[1] ?? '',
    number: parseInt(match[2] ?? '0', 10),
    suffix: match[3] ?? '',
    raw: val
  };
};

const parsed = parseValue(value);
const digitCount = String(parsed.number).length;
---

<span
  class:list={['odometer-value', className]}
  data-odometer
  data-target={parsed.number}
  data-prefix={parsed.prefix}
  data-suffix={parsed.suffix}
  data-raw={parsed.raw}
  data-digits={digitCount}
  style={`min-width: ${digitCount + parsed.prefix.length + parsed.suffix.length}ch`}
>
  <!-- Initial state shows the full value for SSR/print/no-JS -->
  <span class="odometer-prefix">{parsed.prefix}</span>
  <span class="odometer-number">{parsed.number}</span>
  <span class="odometer-suffix">{parsed.suffix}</span>
</span>

<style>
  .odometer-value {
    display: inline-flex;
    align-items: baseline;
    /* Prevent layout shift during scramble/count phases */
    min-width: var(--odometer-width, auto);
  }

  .odometer-number {
    /* Use tabular figures for consistent digit widths */
    font-variant-numeric: tabular-nums;
    display: inline-block;
    text-align: right;
  }

  .odometer-prefix,
  .odometer-suffix {
    /* Prefixes and suffixes don't animate */
  }

  /* Print: no animation, just show the value */
  @media print {
    .odometer-value {
      /* Value is already shown correctly via SSR */
    }
  }
</style>

<script is:inline>
  // Odometer animation with forensic scramble effect
  (function() {
    // Guard against multiple executions using data attribute instead of window property
    if (document.documentElement.dataset.odometerInit) return;
    document.documentElement.dataset.odometerInit = 'true';

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // Timing constants
    const SCRAMBLE_DURATION = 300;
    const COUNT_DURATION = 900;

    // Easing function (ease-out cubic)
    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    // Generate random digits string of specified length
    function randomDigits(length) {
      let result = '';
      for (let i = 0; i < length; i++) {
        result += Math.floor(Math.random() * 10);
      }
      return result;
    }

    function animateOdometer(el) {
      const target = parseInt(el.getAttribute('data-target') || '0', 10);
      const numberSpan = el.querySelector('.odometer-number');
      const digitCount = parseInt(el.getAttribute('data-digits') || '1', 10);

      if (!numberSpan || target <= 0 || isNaN(target)) return;

      // Skip animation for reduced motion - show final value immediately
      if (prefersReducedMotion) {
        numberSpan.textContent = target.toString();
        return;
      }

      const targetStr = target.toString();

      // Phase 1: Scramble (300ms of random digits)
      let scrambleStart = null;

      function scramble(currentTime) {
        if (scrambleStart === null) {
          scrambleStart = currentTime;
        }

        const elapsed = currentTime - scrambleStart;

        if (elapsed < SCRAMBLE_DURATION) {
          // Show random digits during scramble phase
          numberSpan.textContent = randomDigits(digitCount);
          requestAnimationFrame(scramble);
        } else {
          // Transition to count-up phase
          startCountUp();
        }
      }

      // Phase 2: Count-up animation
      function startCountUp() {
        let countStart = null;

        function count(currentTime) {
          if (countStart === null) {
            countStart = currentTime;
          }

          const elapsed = currentTime - countStart;
          const progress = Math.min(Math.max(elapsed / COUNT_DURATION, 0), 1);
          const easedProgress = easeOutCubic(progress);

          const currentValue = Math.max(0, Math.round(easedProgress * target));
          numberSpan.textContent = currentValue.toString();

          if (progress < 1) {
            requestAnimationFrame(count);
          } else {
            // Ensure final value is exact
            numberSpan.textContent = targetStr;
          }
        }

        requestAnimationFrame(count);
      }

      // Start with scramble phase
      requestAnimationFrame(scramble);
    }

    function initOdometers() {
      const odometers = document.querySelectorAll('[data-odometer]');

      // If reduced motion is preferred, just show values without observer
      if (prefersReducedMotion) {
        odometers.forEach(function(el) {
          const target = el.getAttribute('data-target') || '0';
          const numberSpan = el.querySelector('.odometer-number');
          if (numberSpan) {
            numberSpan.textContent = target;
          }
        });
        return;
      }

      // Use IntersectionObserver to trigger animation when 20% visible
      if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver(function(entries) {
          entries.forEach(function(entry) {
            if (entry.isIntersecting) {
              animateOdometer(entry.target);
              observer.unobserve(entry.target);
            }
          });
        }, {
          threshold: 0.2 // Trigger when 20% visible
        });

        odometers.forEach(function(el) {
          observer.observe(el);
        });
      } else {
        // Fallback for browsers without IntersectionObserver
        odometers.forEach(animateOdometer);
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initOdometers);
    } else {
      initOdometers();
    }
  })();
</script>
