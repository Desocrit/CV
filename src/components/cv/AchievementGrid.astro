---
import Odometer from '../ui/Odometer.astro';

interface Achievement {
  metric: string;
  headline: string;
  description: string;
}

interface Props {
  achievements: Achievement[];
  class?: string;
}

const { achievements, class: className = '' } = Astro.props;

// Transform metric names into SCREAMING_SNAKE_CASE for labels
const toSnakeCase = (str: string) =>
  str.toUpperCase().replace(/\s+/g, '_');
---

<section
  aria-label="Key Achievements"
  class:list={['achievement-grid', className]}
>
  <!-- Pass 3: Three borderless columns separated by whitespace -->
  <div class="flex flex-col md:flex-row md:justify-between gap-8">
    {achievements.map((achievement) => (
      <div class="flex flex-col gap-1 items-center text-center">
        <!-- Metric: Large Geist Mono in White with odometer animation -->
        <data
          value={achievement.headline}
          class="font-mono text-fluid-xl font-semibold tracking-tight text-foreground whitespace-nowrap leading-none"
        >
          <Odometer value={achievement.headline} />
        </data>
        <!-- Label: Small-caps Geist Mono in Purple -->
        <span class="achievement-label font-mono text-[10px] uppercase tracking-[0.15em] mt-0.5">
          {toSnakeCase(achievement.metric)}
        </span>
        <!-- Description: One sentence in Geist Sans Slate -->
        <p class="text-fluid-xs text-muted-foreground leading-snug mt-1">
          {achievement.description}
        </p>
      </div>
    ))}
  </div>
</section>

<style>
  /* Label - purple accent */
  .achievement-label {
    color: var(--color-accent-purple);
  }

  /* Metric hero glow state when in view */
  .achievement-metric-glow {
    text-shadow:
      0 0 8px color-mix(in srgb, var(--color-accent-purple) 40%, transparent),
      0 0 16px color-mix(in srgb, var(--color-accent-purple) 20%, transparent);
    transition: text-shadow 0.6s ease-out;
  }

  /* Print: Compact inline display */
  @media print {
    .achievement-grid {
      margin: 0;
    }

    .achievement-grid > div {
      display: flex;
      flex-direction: row;
      gap: 1rem;
    }

    .achievement-grid > div > div {
      flex: 1;
    }

    .achievement-label {
      color: #333 !important;
    }

    .achievement-metric-glow {
      text-shadow: none;
    }
  }
</style>

<script>
  function initAchievementGlow() {
    const metrics = document.querySelectorAll('.achievement-grid data');
    if (metrics.length === 0) return;

    // Respect reduced motion preference
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add('achievement-metric-glow');
          }
        });
      },
      { threshold: 0.5, rootMargin: '0px 0px -10% 0px' }
    );

    metrics.forEach((metric) => observer.observe(metric));
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAchievementGlow);
  } else {
    initAchievementGlow();
  }
</script>
